<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChessLab</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .board-container {
            position: relative;
            width: 100%;
        }

        .board-coordinates {
            position: relative;
        }

        .file-labels {
            display: flex;
            justify-content: space-around;
            margin-top: 4px;
            padding: 0 2px;
        }

        .file-label {
            flex: 1;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #94a3b8;
            user-select: none;
        }

        .rank-labels {
            position: absolute;
            right: -24px;
            top: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            padding: 2px 0;
        }

        .rank-label {
            flex: 1;
            display: flex;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            color: #94a3b8;
            user-select: none;
        }

        /* Board Themes */
        :root {
            --board-light: #ebecd0;
            --board-dark: #739552;
        }

        .theme-classic {
            --board-light: #ebecd0;
            --board-dark: #739552;
        }

        .theme-wood {
            --board-light: #f0d9b5;
            --board-dark: #b58863;
        }

        .theme-ocean {
            --board-light: #dee3e6;
            --board-dark: #8ca2ad;
        }

        .theme-purple {
            --board-light: #e2e2e2;
            --board-dark: #8877b7;
        }

        .theme-gray {
            --board-light: #e0e0e0;
            --board-dark: #a0a0a0;
            /* Lighter gray (was #808080) */
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            position: relative;
            transition: background-color 0.3s ease;
        }

        .square.light {
            background-color: var(--board-light);
        }

        .square.dark {
            background-color: var(--board-dark);
        }

        /* Add subtle texture overlay */
        .chess-board {
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .square.highlight {
            box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.6);
        }

        /* Adaptive last move highlight - Stronger Glossy Style */
        .square.last-move.light,
        .square.last-move.dark {
            background-color: rgba(255, 255, 255, 0.3) !important;
            /* Increased opacity */
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.4);
            /* Stronger inner glow */
            background-blend-mode: overlay;
        }

        /* Fallback/Overlay - Stronger Shine */
        .square.last-move::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, 0.2) 100%);
            pointer-events: none;
        }

        .square.drag-over {
            box-shadow: inset 0 0 0 4px rgba(99, 102, 241, 0.9);
            background-blend-mode: overlay;
        }

        .piece.dragging {
            opacity: 0.4;
            transform: scale(0.9);
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px rgba(99, 102, 241, 0.9);
        }

        .square:hover {
            filter: brightness(1.05);
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            box-sizing: border-box;
        }

        .piece {
            width: 85%;
            height: 85%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: transform 0.15s ease;
            filter: drop-shadow(1px 2px 2px rgba(0, 0, 0, 0.3));
            cursor: grab;
        }

        .piece:active {
            cursor: grabbing;
        }

        .piece.dragging {
            opacity: 0.5;
        }

        .piece-icon {
            width: 32px;
            height: 32px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: inline-block;
            vertical-align: middle;
            filter: drop-shadow(1px 1px 1px rgba(0, 0, 0, 0.3));
        }

        .piece-icon-sm {
            width: 20px;
            height: 20px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: inline-block;
            vertical-align: middle;
        }

        /* Chess.com style piece images using SVG data URIs */
        /* White pieces */
        .piece-wK {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5'%3E%3Cpath stroke-linejoin='miter' d='M22.5 11.63V6M20 8h5'/%3E%3Cpath fill='%23fff' stroke-linecap='butt' stroke-linejoin='miter' d='M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5'/%3E%3Cpath fill='%23fff' d='M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7'/%3E%3Cpath d='M12.5 30c5.5-3 14.5-3 20 0M12.5 33.5c5.5-3 14.5-3 20 0M12.5 37c5.5-3 14.5-3 20 0'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-wQ {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5'%3E%3Cpath d='M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z'/%3E%3Cpath stroke-linecap='butt' d='M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15L14 11v14L7 14l2 12z'/%3E%3Cpath stroke-linecap='butt' d='M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z'/%3E%3Cpath fill='none' d='M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-wR {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5'%3E%3Cpath stroke-linecap='butt' d='M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5'/%3E%3Cpath d='M34 14l-3 3H14l-3-3'/%3E%3Cpath stroke-linecap='butt' stroke-linejoin='miter' d='M31 17v12.5H14V17'/%3E%3Cpath d='M31 29.5l1.5 2.5h-20l1.5-2.5'/%3E%3Cpath fill='none' stroke-linejoin='miter' d='M11 14h23'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-wB {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5'%3E%3Cg fill='%23fff' stroke-linecap='butt'%3E%3Cpath d='M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.35.49-2.32.47-3-.5 1.35-1.46 3-2 3-2z'/%3E%3Cpath d='M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z'/%3E%3Cpath d='M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z'/%3E%3C/g%3E%3Cpath stroke-linejoin='miter' d='M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-wN {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5'%3E%3Cpath fill='%23fff' d='M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21'/%3E%3Cpath fill='%23fff' d='M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3'/%3E%3Cpath fill='%23000' d='M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-wP {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cpath d='M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z' fill='%23fff' stroke='%23000' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        /* Black pieces - with white outlines, using thinner strokes to compensate for irradiation effect */
        .piece-bK {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='none' fill-rule='evenodd' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2'%3E%3Cpath stroke-linejoin='miter' d='M22.5 11.63V6M20 8h5'/%3E%3Cpath fill='%23000' stroke-linecap='butt' stroke-linejoin='miter' d='M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5'/%3E%3Cpath fill='%23000' d='M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7'/%3E%3Cpath d='M12.5 30c5.5-3 14.5-3 20 0M12.5 33.5c5.5-3 14.5-3 20 0M12.5 37c5.5-3 14.5-3 20 0'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-bQ {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='%23000' fill-rule='evenodd' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2'%3E%3Cpath d='M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z'/%3E%3Cpath stroke-linecap='butt' d='M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15L14 11v14L7 14l2 12z'/%3E%3Cpath stroke-linecap='butt' d='M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z'/%3E%3Cpath fill='none' d='M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-bR {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='%23000' fill-rule='evenodd' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2'%3E%3Cpath stroke-linecap='butt' d='M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5'/%3E%3Cpath d='M34 14l-3 3H14l-3-3'/%3E%3Cpath stroke-linecap='butt' stroke-linejoin='miter' d='M31 17v12.5H14V17'/%3E%3Cpath d='M31 29.5l1.5 2.5h-20l1.5-2.5'/%3E%3Cpath fill='none' stroke-linejoin='miter' d='M11 14h23'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-bB {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='none' fill-rule='evenodd' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2'%3E%3Cg fill='%23000' stroke-linecap='butt'%3E%3Cpath d='M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.35.49-2.32.47-3-.5 1.35-1.46 3-2 3-2z'/%3E%3Cpath d='M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z'/%3E%3Cpath d='M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z'/%3E%3C/g%3E%3Cpath stroke-linejoin='miter' d='M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-bN {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cg fill='none' fill-rule='evenodd' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2'%3E%3Cpath fill='%23000' d='M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21'/%3E%3Cpath fill='%23000' d='M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3'/%3E%3Cpath fill='%23fff' d='M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z'/%3E%3C/g%3E%3C/svg%3E");
        }

        .piece-bP {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3E%3Cpath d='M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z' fill='%23000' stroke='%23fff' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        .move-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .move-item:hover {
            background: rgba(99, 102, 241, 0.2);
        }

        .move-item.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
        }

        /* Promotion Modal */
        .promotion-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(8px);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            /* Ensure high z-index */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .promotion-modal.hidden {
            display: none;
        }

        .promotion-option {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .promotion-option:hover {
            background: rgba(99, 102, 241, 0.5);
            transform: translateY(-2px);
        }

        .promotion-option .piece {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .game-card {
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .game-card:hover {
            transform: translateX(4px);
            background: rgba(99, 102, 241, 0.1);
        }

        .game-card.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
            border-left: 3px solid #6366f1;
        }

        .drop-zone {
            border: 3px dashed #cbd5e1;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.1);
            transform: scale(1.02);
        }

        .nav-btn {
            transition: all 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #334155;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .progress-bar {
            width: 300px;
            height: 8px;
            background: #334155;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .pagination-btn {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #6366f1;
        }

        .pagination-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .player-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 6px;
        }

        .player-badge.white {
            background: linear-gradient(135deg, #f0f0f0 0%, #d0d0d0 100%);
            border: 2px solid #999;
        }

        .player-badge.black {
            background: linear-gradient(135deg, #404040 0%, #1a1a1a 100%);
            border: 2px solid #666;
        }

        /* Stockfish Analysis */
        .eval-bar {
            width: 24px;
            height: 100%;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .eval-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #f0f0f0;
            transition: height 0.3s ease;
        }

        .eval-score {
            position: absolute;
            right: -8px;
            transform: translateY(-50%);
            font-size: 10px;
            font-weight: 700;
            background: rgba(17, 24, 39, 0.85);
            color: #8b5cf6;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .eval-score::after {
            content: '';
            position: absolute;
            left: -4px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-right: 4px solid rgba(17, 24, 39, 0.85);
        }

        .analysis-line {
            font-family: monospace;
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .best-move {
            color: #4ade80;
            font-weight: bold;
        }

        .engine-toggle {
            position: relative;
            width: 48px;
            height: 24px;
            background: #475569;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .engine-toggle.active {
            background: #22c55e;
        }

        .engine-toggle::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .engine-toggle.active::after {
            transform: translateX(24px);
        }

        .thinking-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: '.';
            }

            40% {
                content: '..';
            }

            60%,
            100% {
                content: '...';
            }
        }

        .turn-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }

        .turn-indicator.white {
            background: linear-gradient(135deg, #f0f0f0 0%, #d0d0d0 100%);
            color: #1a1a1a;
        }

        .turn-indicator.black {
            background: linear-gradient(135deg, #404040 0%, #1a1a1a 100%);
            color: #f0f0f0;
        }

        .turn-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .turn-indicator.white .turn-dot {
            background: #22c55e;
        }

        .turn-indicator.black .turn-dot {
            background: #22c55e;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .analysis-mode-badge {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .move-token-white {
            color: #ffffff;
        }

        .move-token-black {
            color: #4b5563;
        }

        .eval-inline {
            position: relative;
            height: 10px;
            border-radius: 9999px;
            background: #334155;
            overflow: hidden;
        }

        .eval-inline-fill-white {
            position: absolute;
            left: 0;
            height: 100%;
            background: #ffffff;
        }

        .eval-inline-fill-black {
            position: absolute;
            right: 0;
            height: 100%;
            background: #0f172a;
        }

        .eval-inline-mid {
            display: none;
        }

        .eval-inline-label {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: 700;
            color: #8b5cf6;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body class="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 min-h-screen text-white">
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <div class="progress-bar">
            <div id="progressFill" class="progress-fill" style="width: 0%"></div>
        </div>
        <p id="loadingText" class="text-slate-400 mt-4">Loading games...</p>
        <p id="loadingStats" class="text-slate-500 text-sm mt-2"></p>
    </div>



    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1
                class="text-4xl font-bold bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-400 bg-clip-text text-transparent mb-2">
                <!-- <span class="piece-icon piece-wK inline-block mr-2"></span> -->
                ChessLab
                <!-- <span class="piece-icon piece-wK inline-block mr-2"></span>

                <span class="piece-icon piece-bK inline-block mr-2"></span> -->
            </h1>
            <p class="text-slate-400">Analyze chess games!</p>
        </div>

        <!-- Main Layout -->
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left Panel - Games List -->
            <div class="lg:w-80 flex-shrink-0">
                <div class="bg-slate-800/50 backdrop-blur rounded-xl p-4 border border-slate-700">
                    <h2 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <span class="text-2xl">üìÅ</span> Games
                        <span id="gamesCount" class="ml-auto text-sm font-normal text-slate-400"></span>
                    </h2>

                    <!-- Upload Zone -->
                    <div id="dropZone" class="drop-zone rounded-xl p-6 text-center mb-4 bg-slate-900/50">
                        <div class="text-4xl mb-2">üìÑ</div>
                        <p class="text-slate-400 text-sm mb-3">Drag & drop PGN file here</p>
                        <label class="inline-block cursor-pointer">
                            <span
                                class="bg-gradient-to-r from-indigo-500 to-purple-500 hover:from-indigo-600 hover:to-purple-600 px-4 py-2 rounded-lg text-sm font-medium transition-all">
                                Browse Files
                            </span>
                            <input type="file" id="fileInput" accept=".pgn,.txt" class="hidden">
                        </label>
                    </div>

                    <!-- Search -->
                    <div class="mb-4">
                        <input type="text" id="searchInput" placeholder="Search players, events..."
                            class="w-full bg-slate-900/50 border border-slate-600 rounded-lg px-4 py-2 text-sm placeholder-slate-500 focus:outline-none focus:border-indigo-500">
                    </div>

                    <!-- Games List -->
                    <div id="gamesList" class="space-y-2 max-h-72 overflow-y-auto">
                        <p class="text-slate-500 text-sm text-center py-4">No games loaded</p>
                    </div>

                    <!-- Pagination -->
                    <div id="pagination"
                        class="flex items-center justify-between mt-4 pt-4 border-t border-slate-700 hidden">
                        <button id="prevPage" class="pagination-btn bg-slate-700" disabled>‚Üê Prev</button>
                        <span id="pageInfo" class="text-sm text-slate-400">Page 1 / 1</span>
                        <button id="nextPage" class="pagination-btn bg-slate-700">Next ‚Üí</button>
                    </div>

                    <!-- Jump to game -->
                    <div id="jumpToGame" class="mt-3 hidden">
                        <div class="flex gap-2">
                            <input type="number" id="jumpInput" min="1" placeholder="Game #"
                                class="flex-1 bg-slate-900/50 border border-slate-600 rounded-lg px-3 py-1.5 text-sm focus:outline-none focus:border-indigo-500">
                            <button id="jumpBtn"
                                class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm">Go</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center - Chess Board -->
            <div class="flex-1 flex flex-col items-center">
                <!-- Game Info (hidden by default) -->
                <div id="gameInfo"
                    class="w-full max-w-2xl bg-slate-800/50 backdrop-blur rounded-xl p-4 mb-4 border border-slate-700 hidden">
                    <div class="text-center text-slate-400">Load a PGN file to view game details</div>
                </div>

                <!-- Board -->
                <div class="w-full max-w-2xl">
                    <div class="board-container">
                        <div class="board-coordinates">
                            <div id="chessBoard" class="chess-board w-full">
                                <!-- Board will be generated here -->
                            </div>
                            <div class="rank-labels">
                                <div class="rank-label">8</div>
                                <div class="rank-label">7</div>
                                <div class="rank-label">6</div>
                                <div class="rank-label">5</div>
                                <div class="rank-label">4</div>
                                <div class="rank-label">3</div>
                                <div class="rank-label">2</div>
                                <div class="rank-label">1</div>
                            </div>
                        </div>
                        <!-- Promotion Modal -->
                        <div id="promotionModal" class="promotion-modal hidden">
                            <div class="promotion-option" onclick="selectPromotion('q')">
                                <div class="piece piece-wQ"></div>
                            </div>
                            <div class="promotion-option" onclick="selectPromotion('r')">
                                <div class="piece piece-wR"></div>
                            </div>
                            <div class="promotion-option" onclick="selectPromotion('b')">
                                <div class="piece piece-wB"></div>
                            </div>
                            <div class="promotion-option" onclick="selectPromotion('n')">
                                <div class="piece piece-wN"></div>
                            </div>
                        </div>
                        <div class="file-labels">
                            <div class="file-label">a</div>
                            <div class="file-label">b</div>
                            <div class="file-label">c</div>
                            <div class="file-label">d</div>
                            <div class="file-label">e</div>
                            <div class="file-label">f</div>
                            <div class="file-label">g</div>
                            <div class="file-label">h</div>
                        </div>
                    </div>

                    <!-- Board Editing Controls -->
                    <div class="flex items-center justify-between mt-1 text-xs">
                        <div class="flex items-center gap-4">
                            <span class="text-slate-400">üí° Drag/Click to move ‚Ä¢ Right-click any piece to remove <br> üí°
                                Movement Rules: Same color ‚Üí SWAP, Opposite color ‚Üí CAPTURE, Empty square ‚Üí MOVE</span>
                            <!-- <span class="text-slate-400">üí° Movement Rules: Same color ‚Üí SWAP, Opposite color ‚Üí
                                CAPTUR,<br> Empty square ‚Üí MOVE</span> -->
                            <!-- <div class="flex items-center gap-1 border-l border-slate-700 pl-4">
                                <span class="text-slate-400">Theme:</span>
                                <select id="boardThemeSelect"
                                    class="bg-slate-700 text-xs px-2 py-1 rounded border border-slate-600 text-slate-300 focus:outline-none focus:border-indigo-500">
                                    <option value="theme-classic" selected>Classic Green</option>
                                    <option value="theme-wood">Elegant Wood</option>
                                    <option value="theme-ocean">Ocean Blue</option>
                                    <option value="theme-purple">Royal Purple</option>
                                    <option value="theme-gray">Modern Gray</option>
                                </select>
                            </div> -->
                        </div>
                        <!-- <button id="undoEditBtn" onclick="undoLastMove()"
                            class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-slate-300 transition-colors opacity-50"
                            disabled>
                            ‚Ü©Ô∏è Undo
                        </button> -->
                    </div>
                </div>

                <!-- Navigation Controls -->
                <div class="w-full max-w-2xl mt-6 space-y-4">
                    <!-- Move Navigation -->
                    <!-- Playback and Game Controls -->
                    <!-- Playback and Game Controls -->
                    <div class="flex items-center justify-center gap-2 whitespace-nowrap overflow-x-auto py-1">
                        <button id="btnAutoPlay"
                            class="flex items-center gap-1.5 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 px-3 py-1.5 rounded text-xs text-white font-medium transition-colors">
                            <span id="btnAutoPlayIcon">
                                <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5"
                                    fill="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                                </svg>
                            </span>
                            <span>Auto</span>
                        </button>
                        <select id="playSpeed"
                            class="bg-slate-700 text-xs px-2 py-1.5 rounded border border-slate-600 text-slate-300 focus:outline-none focus:border-indigo-500">
                            <option value="2000">Slow</option>
                            <option value="1000" selected>Normal</option>
                            <option value="500">Fast</option>
                            <option value="250">Very Fast</option>
                        </select>
                        <button id="btnResetBoard"
                            class="flex items-center gap-1.5 bg-gradient-to-r from-indigo-500 to-purple-500 hover:from-indigo-600 hover:to-purple-600 px-3 py-1.5 rounded text-xs text-white font-medium transition-colors"
                            title="Start New Board">
                            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            <span>New</span>
                        </button>
                        <button id="undoEditBtn" onclick="undoLastMove()"
                            class="flex items-center gap-1.5 px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-slate-300 transition-colors opacity-50"
                            disabled>
                            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="1 4 1 10 7 10"></polyline>
                                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                            </svg>
                            <span>Undo</span>
                        </button>
                        <div class="flex items-center gap-2 border-l border-slate-700 pl-2">
                            <span class="text-slate-400 text-xs">Theme:</span>
                            <select id="boardThemeSelect"
                                class="bg-slate-700 text-xs px-2 py-1.5 rounded border border-slate-600 text-slate-300 focus:outline-none focus:border-indigo-500">
                                <option value="theme-classic" selected>Classic</option>
                                <option value="theme-wood">Wood</option>
                                <option value="theme-ocean">Ocean</option>
                                <option value="theme-purple">Purple</option>
                                <option value="theme-gray">Gray</option>
                            </select>
                        </div>
                    </div>

                    <!-- Move Navigation -->
                    <div class="flex items-center justify-center gap-2">
                        <button id="btnFirst"
                            class="nav-btn bg-slate-700 hover:bg-indigo-600 px-4 py-3 rounded-lg font-medium flex items-center justify-center"
                            title="First Move">
                            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="11 17 6 12 11 7"></polyline>
                                <polyline points="18 17 13 12 18 7"></polyline>
                            </svg>
                        </button>
                        <button id="btnPrev"
                            class="nav-btn bg-slate-700 hover:bg-indigo-600 px-4 py-3 rounded-lg font-medium flex items-center justify-center"
                            title="Previous Move">
                            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                        </button>
                        <span id="moveCounter"
                            class="px-4 py-2 bg-slate-800 rounded-lg text-slate-400 min-w-24 text-center">
                            0 / 0
                        </span>
                        <button id="btnNext"
                            class="nav-btn bg-slate-700 hover:bg-indigo-600 px-4 py-3 rounded-lg font-medium flex items-center justify-center"
                            title="Next Move">
                            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                        </button>
                        <button id="btnLast"
                            class="nav-btn bg-slate-700 hover:bg-indigo-600 px-4 py-3 rounded-lg font-medium flex items-center justify-center"
                            title="Last Move">
                            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="13 17 18 12 13 7"></polyline>
                                <polyline points="6 17 11 12 6 7"></polyline>
                            </svg>
                        </button>
                    </div>

                    <!-- Game Navigation -->
                    <div class="flex items-center justify-center gap-2">
                        <button id="btnPrevGame"
                            class="nav-btn bg-slate-700 hover:bg-indigo-600 px-4 py-2 rounded-lg text-sm flex items-center gap-1.5"
                            title="Previous Game">
                            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                                <line x1="5" y1="19" x2="5" y2="5"></line>
                            </svg>
                            <span>Prev Game</span>
                        </button>
                        <span id="gameCounter"
                            class="px-4 py-2 bg-slate-800 rounded-lg text-slate-400 text-sm min-w-28 text-center">
                            Game 0 / 0
                        </span>
                        <button id="btnNextGame"
                            class="nav-btn bg-slate-700 hover:bg-indigo-600 px-4 py-2 rounded-lg text-sm flex items-center gap-1.5"
                            title="Next Game">
                            <span>Next Game</span>
                            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                                <line x1="19" y1="5" x2="19" y2="19"></line>
                            </svg>
                        </button>
                    </div>

                    <!-- Reset Analysis Button -->
                    <div id="analysisControls" class="flex justify-center hidden">
                        <button id="btnResetPosition"
                            class="flex items-center gap-2 nav-btn bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 px-6 py-2 rounded-lg font-medium">
                            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2.5"
                                fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="1 4 1 10 7 10"></polyline>
                                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                            </svg>
                            <span>Reset to Game Position</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Moves & Analysis -->
            <div class="lg:w-80 flex-shrink-0 space-y-4">
                <!-- Moves Panel -->
                <div class="bg-slate-800/50 backdrop-blur rounded-xl p-4 border border-slate-700">
                    <h2 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <span class="text-2xl">üìã</span> Moves
                    </h2>
                    <div id="movesList" class="max-h-64 overflow-y-auto">
                        <p class="text-slate-500 text-sm text-center py-4">No moves to display</p>
                    </div>
                </div>

                <!-- Stockfish Analysis Panel -->
                <div class="bg-slate-800/50 backdrop-blur rounded-xl p-4 border border-slate-700">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold flex items-center gap-2">
                            <span class="text-2xl">üêü</span> Stockfish
                            <span id="engineVersion" class="text-xs text-slate-500 font-normal"></span>
                        </h2>
                        <div class="flex items-center gap-3">
                            <span id="engineStatus" class="text-xs text-slate-500">Off</span>
                            <div id="engineToggle" class="engine-toggle" title="Toggle Engine"></div>
                        </div>
                    </div>

                    <!-- Engine Version Selector -->
                    <div id="engineVersionSelector" class="mb-4">
                        <label class="text-xs text-slate-400 block mb-2">Engine Version:</label>
                        <select id="engineVersionSelect"
                            class="w-full bg-slate-700 text-sm px-3 py-2 rounded-lg border border-slate-600">
                            <option value="lite-single" selected>Stockfish 17.1 Lite (~7MB, Fast)</option>
                            <option value="large-single">Stockfish 17.1 Strong (~75MB, Powerful)</option>
                        </select>
                        <p class="text-xs text-slate-500 mt-1">Large version downloads more data but provides stronger
                            analysis.</p>
                    </div>

                    <!-- Engine Settings -->
                    <div id="engineSettings" class="mb-4 hidden">
                        <div class="flex items-center gap-3 mb-2">
                            <label class="text-xs text-slate-400">Depth:</label>
                            <input type="range" id="depthSlider" min="10" max="35" value="22"
                                class="flex-1 accent-indigo-500">
                            <span id="depthValue" class="text-xs text-slate-300 w-6">22</span>
                        </div>
                        <div class="flex items-center gap-3">
                            <label class="text-xs text-slate-400">Lines:</label>
                            <select id="multiPV" class="bg-slate-700 text-xs px-2 py-1 rounded border border-slate-600">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                            </select>
                        </div>
                    </div>

                    <!-- Evaluation Display -->
                    <div id="analysisDisplay" class="hidden">
                        <div class="grid grid-cols-1 gap-4">
                            <div class="analysis-card rounded-lg border border-slate-700 p-3">
                                <div class="flex items-center justify-between mb-1">
                                    <div class="flex items-center gap-2">
                                        <span class="text-sm font-semibold">White to move</span>
                                        <span id="thinkingIndicatorWhite" class="thinking-dots hidden"></span>
                                    </div>
                                    <span id="currentDepthWhite" class="text-xs text-slate-400">0</span>
                                </div>
                                <div class="flex gap-3 mb-1">
                                    <div class="eval-bar h-28">
                                        <div id="evalFillWhite" class="eval-fill" style="height: 50%"></div>
                                        <span id="evalScoreBarWhite" class="eval-score text-white">0.0</span>
                                    </div>
                                </div>

                                <div class="flex-1">
                                    <div class="flex items-center justify-between pl-0">
                                        <span class="text-xs font-semibold text-slate-400">Eval</span>
                                        <div class="eval-inline w-full max-w-[160px] ml-2" id="evalInlineWhite">
                                            <div class="eval-inline-fill-black" id="evalInlineWhiteLeftFill"
                                                style="width: 0%"></div>
                                            <div class="eval-inline-fill-white" id="evalInlineWhiteRightFill"
                                                style="width: 0%"></div>
                                            <div class="eval-inline-mid"></div>
                                            <span id="evalInlineWhiteLabel" class="eval-inline-label">0.0</span>
                                        </div>
                                    </div>
                                    <div class="text-xs text-slate-400 pl-0 mb-3">
                                        Best move: <span id="bestMoveWhite" class="best-move">-</span>
                                    </div>
                                </div>

                                <div id="analysisLinesWhite" class="space-y-1">
                                    <p class="text-slate-500 text-xs text-center py-2">Start engine to analyze</p>
                                </div>
                            </div>

                            <div class="analysis-card rounded-lg border border-slate-700 p-3">
                                <div class="flex items-center justify-between mb-1">
                                    <div class="flex items-center gap-2">
                                        <span class="text-sm font-semibold">Black to move</span>
                                        <span id="thinkingIndicatorBlack" class="thinking-dots hidden"></span>
                                    </div>
                                    <span id="currentDepthBlack" class="text-xs text-slate-400">0</span>
                                </div>
                                <div class="flex gap-3 mb-1">
                                    <div class="eval-bar h-28">
                                        <div id="evalFillBlack" class="eval-fill" style="height: 50%"></div>
                                        <span id="evalScoreBarBlack" class="eval-score text-white">0.0</span>
                                    </div>
                                </div>
                                <div class="flex-1">
                                    <div class="flex items-center justify-between pl-0">
                                        <span class="text-xs font-semibold text-slate-400">Eval</span>
                                        <div class="eval-inline w-full max-w-[160px] ml-2" id="evalInlineBlack">
                                            <div class="eval-inline-fill-black" id="evalInlineBlackLeftFill"
                                                style="width: 0%"></div>
                                            <div class="eval-inline-fill-white" id="evalInlineBlackRightFill"
                                                style="width: 0%"></div>
                                            <div class="eval-inline-mid"></div>
                                            <span id="evalInlineBlackLabel" class="eval-inline-label">0.0</span>
                                        </div>
                                    </div>
                                    <div class="text-xs text-slate-400 pl-0 mb-3">
                                        Best move: <span id="bestMoveBlack" class="best-move">-</span>
                                    </div>
                                </div>

                                <div id="analysisLinesBlack" class="space-y-1">
                                    <p class="text-slate-500 text-xs text-center py-2">Start engine to analyze</p>
                                </div>
                            </div>
                        </div>

                        <div class="mt-3 text-center text-xs text-slate-400">
                            <span>üí° Being a move ahead or behind can reshape the position. Compare both sides and you
                                will spot ideas you might miss. As a wise man once said‚Ä¶ probably.</span>
                        </div>
                    </div>

                    <!-- Engine Loading State -->
                    <div id="engineLoading" class="hidden text-center py-4">
                        <div
                            class="inline-block w-6 h-6 border-2 border-slate-600 border-t-indigo-500 rounded-full animate-spin mb-2">
                        </div>
                        <p class="text-xs text-slate-400">Loading Stockfish...</p>
                    </div>

                    <!-- Engine Off State -->
                    <div id="engineOffState" class="text-center py-4">
                        <p class="text-slate-500 text-sm">Toggle to enable analysis</p>
                        <p class="text-slate-600 text-xs mt-1">Runs locally in your browser</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initial board setup
        const INITIAL_BOARD = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // Piece to CSS class mapping
        const PIECE_CLASSES = {
            'K': 'piece-wK', 'Q': 'piece-wQ', 'R': 'piece-wR', 'B': 'piece-wB', 'N': 'piece-wN', 'P': 'piece-wP',
            'k': 'piece-bK', 'q': 'piece-bQ', 'r': 'piece-bR', 'b': 'piece-bB', 'n': 'piece-bN', 'p': 'piece-bP'
        };

        // State
        let games = [];
        let filteredGames = [];
        let currentGameIndex = -1;
        let currentMoveIndex = -1;
        let boardHistory = [];
        let autoPlayInterval = null;

        // Analysis mode state
        let analysisMode = false;
        let analysisBoard = null;
        let analysisWhiteToMove = true;
        let selectedSquare = null;
        let validMoves = [];

        // Pagination
        const GAMES_PER_PAGE = 50;
        let currentPage = 0;

        // DOM Elements
        const chessBoard = document.getElementById('chessBoard');
        const gamesList = document.getElementById('gamesList');
        const movesList = document.getElementById('movesList');
        const gameInfo = document.getElementById('gameInfo');
        const moveCounter = document.getElementById('moveCounter');
        const gameCounter = document.getElementById('gameCounter');
        const gamesCount = document.getElementById('gamesCount');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const progressFill = document.getElementById('progressFill');
        const loadingText = document.getElementById('loadingText');
        const loadingStats = document.getElementById('loadingStats');
        const searchInput = document.getElementById('searchInput');
        const pagination = document.getElementById('pagination');
        const jumpToGame = document.getElementById('jumpToGame');
        const prevPage = document.getElementById('prevPage');
        const nextPage = document.getElementById('nextPage');
        const pageInfo = document.getElementById('pageInfo');
        const analysisControls = document.getElementById('analysisControls');
        const analysisBadge = document.getElementById('analysisBadge');
        const promotionModal = document.getElementById('promotionModal');

        // Show/hide loading
        function showLoading(show, progress = 0, text = 'Loading games...', stats = '') {
            if (show) {
                loadingOverlay.classList.remove('hidden');
                progressFill.style.width = `${progress}%`;
                loadingText.textContent = text;
                loadingStats.textContent = stats;
            } else {
                loadingOverlay.classList.add('hidden');
            }
        }

        function updateProgress(progress, text, stats) {
            progressFill.style.width = `${progress}%`;
            if (text) loadingText.textContent = text;
            if (stats) loadingStats.textContent = stats;
        }

        // Drag state
        let draggedPiece = null;
        let draggedFrom = null;

        // Initialize board
        function initBoard() {
            chessBoard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Add click handler for piece movement
                    square.addEventListener('click', () => handleSquareClick(row, col));

                    // Right-click to remove piece
                    square.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRemovePiece(row, col);
                    });

                    // Drag and drop handlers
                    square.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        square.classList.add('drag-over');
                    });

                    square.addEventListener('dragleave', () => {
                        square.classList.remove('drag-over');
                    });

                    square.addEventListener('drop', (e) => {
                        e.preventDefault();
                        square.classList.remove('drag-over');
                        if (draggedFrom) {
                            handleDrop(row, col);
                        }
                    });

                    chessBoard.appendChild(square);
                }
            }
        }

        // Handle right-click to remove piece (except kings)
        function handleRemovePiece(row, col) {
            if (!analysisMode) {
                // Enter analysis mode first
                analysisMode = true;
                analysisBoard = copyBoard(getCurrentBoard());
                analysisWhiteToMove = (currentMoveIndex + 1) % 2 === 0;
            }

            const board = analysisBoard;
            const piece = board[row][col];

            if (!piece) return; // No piece to remove

            // Cannot remove kings
            if (piece.toUpperCase() === 'K') {
                return;
            }

            saveUndoState();
            board[row][col] = null;
            renderBoard(board);

            // Trigger analysis update
            if (engineEnabled) {
                analyzeCurrentPosition();
            }
        }

        // Handle drag start on pieces
        function handleDragStart(row, col, piece) {
            draggedPiece = piece;
            draggedFrom = { row, col };

            // Visually select the square without re-rendering to avoid breaking drag
            selectedSquare = { row, col };
            const square = chessBoard.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            if (square) {
                square.classList.add('selected');
            }
        }

        // Handle drop on square
        function handleDrop(toRow, toCol) {
            if (!draggedFrom || !draggedPiece) return;

            const fromRow = draggedFrom.row;
            const fromCol = draggedFrom.col;

            // Don't move to same square
            if (fromRow === toRow && fromCol === toCol) {
                draggedPiece = null;
                draggedFrom = null;
                selectedSquare = null;
                renderBoard(getCurrentBoard());
                return;
            }

            executeFreeMove(fromRow, fromCol, toRow, toCol);
            draggedPiece = null;
            draggedFrom = null;
            selectedSquare = null;
            renderBoard(getCurrentBoard());
        }

        // Get current board (either analysis or game)
        function getCurrentBoard() {
            if (analysisMode && analysisBoard) {
                return analysisBoard;
            }
            const historyIndex = currentMoveIndex + 1;
            if (historyIndex >= 0 && historyIndex < boardHistory.length) {
                return boardHistory[historyIndex].board;
            }
            return INITIAL_BOARD;
        }

        // Render board state
        function renderBoard(board, lastMoveSquares = null) {
            const squares = chessBoard.querySelectorAll('.square');
            squares.forEach((square, index) => {
                const row = Math.floor(index / 8);
                const col = index % 8;
                const piece = board[row][col];
                const isLight = (row + col) % 2 === 0;

                // Reset classes
                square.className = `square ${isLight ? 'light' : 'dark'}`;

                if (lastMoveSquares && !analysisMode) {
                    const squareKey = `${row},${col}`;
                    if (lastMoveSquares.includes(squareKey)) {
                        square.classList.add('last-move');
                    }
                }

                // Highlight selected square
                if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                    square.classList.add('selected');
                }

                if (piece) {
                    const pieceClass = PIECE_CLASSES[piece];
                    const pieceDiv = document.createElement('div');
                    pieceDiv.className = `piece ${pieceClass}`;
                    pieceDiv.draggable = true;

                    // Attach drag start handler
                    pieceDiv.addEventListener('dragstart', (e) => {
                        handleDragStart(row, col, piece);
                        e.dataTransfer.effectAllowed = 'move';
                        // Add dragging class for visual feedback
                        setTimeout(() => pieceDiv.classList.add('dragging'), 0);
                    });

                    pieceDiv.addEventListener('dragend', () => {
                        pieceDiv.classList.remove('dragging');
                        // If we are still selecting the dragged piece (drag cancelled), deselect it
                        if (selectedSquare && draggedFrom &&
                            selectedSquare.row === draggedFrom.row &&
                            selectedSquare.col === draggedFrom.col) {
                            selectedSquare = null;
                            const square = chessBoard.querySelector(`.square[data-row="${draggedFrom.row}"][data-col="${draggedFrom.col}"]`);
                            if (square) square.classList.remove('selected');
                        }
                        draggedPiece = null;
                        draggedFrom = null;
                    });

                    square.innerHTML = '';
                    square.appendChild(pieceDiv);
                } else {
                    square.innerHTML = '';
                }
            });
        }

        // Handle square click for free-form piece movement
        function handleSquareClick(row, col) {
            const board = getCurrentBoard();
            const piece = board[row][col];

            // If a square is already selected
            if (selectedSquare) {
                // Clicking same square - deselect
                if (selectedSquare.row === row && selectedSquare.col === col) {
                    selectedSquare = null;
                    renderBoard(board);
                    return;
                }

                // Move the selected piece to this square
                executeFreeMove(selectedSquare.row, selectedSquare.col, row, col);
                selectedSquare = null;
                return;
            }

            // Select a piece (any piece can be selected)
            if (piece) {
                selectedSquare = { row, col };
                renderBoard(board);
            }
        }

        // Execute free-form move (swap same color, capture opponent)
        function executeFreeMove(fromRow, fromCol, toRow, toCol) {
            if (!analysisMode) {
                // Enter analysis mode first
                analysisMode = true;
                analysisBoard = copyBoard(getCurrentBoard());
            }

            const board = analysisBoard;
            const movingPiece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];

            if (!movingPiece) return;

            // Protect kings from being captured
            if (targetPiece && targetPiece.toUpperCase() === 'K') {
                return; // Cannot capture a king
            }

            // Check for pawn promotion
            const isMovingWhite = movingPiece === movingPiece.toUpperCase();
            const isPawn = movingPiece.toUpperCase() === 'P';
            const isPromotion = isPawn && ((isMovingWhite && toRow === 0) || (!isMovingWhite && toRow === 7));

            if (isPromotion) {
                // Store move details for promotion selection
                pendingPromotion = {
                    fromRow, fromCol, toRow, toCol,
                    movingPiece, targetPiece,
                    isSwap: targetPiece && isMovingWhite === (targetPiece === targetPiece.toUpperCase())
                };

                // Show modal
                const modal = document.getElementById('promotionModal');
                modal.classList.remove('hidden');

                // Update modal pieces based on color
                const pieces = modal.querySelectorAll('.piece');
                const color = isMovingWhite ? 'w' : 'b';
                pieces[0].className = `piece piece-${color}Q`;
                pieces[1].className = `piece piece-${color}R`;
                pieces[2].className = `piece piece-${color}B`;
                pieces[3].className = `piece piece-${color}N`;

                return; // Wait for selection
            }

            finalizeMove(fromRow, fromCol, toRow, toCol, movingPiece, targetPiece);
        }

        let pendingPromotion = null;

        function selectPromotion(type) {
            if (!pendingPromotion) return;

            const { fromRow, fromCol, toRow, toCol, movingPiece, targetPiece } = pendingPromotion;
            const isWhite = movingPiece === 'P';
            const promotedPiece = isWhite ? type.toUpperCase() : type.toLowerCase();

            // Hide modal
            document.getElementById('promotionModal').classList.add('hidden');

            // Execute move with promoted piece
            finalizeMove(fromRow, fromCol, toRow, toCol, promotedPiece, targetPiece);
            pendingPromotion = null;
        }

        function finalizeMove(fromRow, fromCol, toRow, toCol, movingPiece, targetPiece) {
            // Check if this move matches the next move in the current game
            const game = games[currentGameIndex];
            if (game && currentMoveIndex < game.moves.length - 1) {
                // We need to know where the next move lands.
                // The `nextMove` object from PGN parser should ideally have from/to coords.
                // Our current parser structure in `handleFile` -> `parsePGN` -> `parseGameText`
                // stores moves as strings (SAN). We need to see how `boardHistory` stores them.

                const nextHistoryState = boardHistory[currentMoveIndex + 2]; // +2 because history is 0-indexed (start pos) + currentMoveIndex

                if (nextHistoryState) {
                    const nextMoveSquares = nextHistoryState.moveSquares; // e.g. ["6,4", "4,4"] (from, to)
                    if (nextMoveSquares && nextMoveSquares.length === 2) {
                        const [nextFromR, nextFromC] = nextMoveSquares[0].split(',').map(Number);
                        const [nextToR, nextToC] = nextMoveSquares[1].split(',').map(Number);

                        if (fromRow === nextFromR && fromCol === nextFromC && toRow === nextToR && toCol === nextToC) {
                            // MATCH! The user played the next move of the game.
                            // Instead of editing the board, just advance the game.
                            goToNext();
                            return;
                        }
                    }
                }
            }

            // If we are here, it's a deviation or free-form move
            if (!analysisMode) {
                analysisMode = true;
                analysisBoard = copyBoard(getCurrentBoard());
                analysisWhiteToMove = (currentMoveIndex + 1) % 2 === 0; // Set turn for analysis mode
            }

            const board = analysisBoard;
            const isMovingWhite = movingPiece === movingPiece.toUpperCase();
            const isTargetWhite = targetPiece && targetPiece === targetPiece.toUpperCase();

            // Save state for undo before making changes
            saveUndoState();

            if (targetPiece) {
                if (isMovingWhite === isTargetWhite) {
                    // Same color - swap pieces
                    board[toRow][toCol] = movingPiece;
                    board[fromRow][fromCol] = targetPiece;
                } else {
                    // Different color - capture (remove opponent piece)
                    board[toRow][toCol] = movingPiece;
                    board[fromRow][fromCol] = null;
                }
            } else {
                // Empty square - just move
                board[toRow][toCol] = movingPiece;
                board[fromRow][fromCol] = null;
            }

            renderBoard(board);

            // Trigger analysis update
            if (engineEnabled) {
                analyzeCurrentPosition();
            }
        }

        // Undo history for board editing
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 200;

        function saveUndoState() {
            if (analysisBoard) {
                undoHistory.push(copyBoard(analysisBoard));
                if (undoHistory.length > MAX_UNDO_HISTORY) {
                    undoHistory.shift();
                }
                updateUndoButton();
            }
        }

        function undoLastMove() {
            if (undoHistory.length > 0) {
                analysisBoard = undoHistory.pop();
                renderBoard(analysisBoard);
                updateUndoButton();
                if (engineEnabled) {
                    analyzeCurrentPosition();
                }
            }
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoEditBtn');
            if (undoBtn) {
                undoBtn.disabled = undoHistory.length === 0;
                undoBtn.classList.toggle('opacity-50', undoHistory.length === 0);
            }
        }

        // Calculate valid moves for a piece
        function calculateValidMoves(board, fromRow, fromCol, piece, isWhite) {
            const moves = [];
            const pieceType = piece.toUpperCase();

            for (let toRow = 0; toRow < 8; toRow++) {
                for (let toCol = 0; toCol < 8; toCol++) {
                    if (fromRow === toRow && fromCol === toCol) continue;

                    const targetPiece = board[toRow][toCol];
                    // Can't capture own pieces
                    if (targetPiece) {
                        const isTargetWhite = targetPiece === targetPiece.toUpperCase();
                        if (isWhite === isTargetWhite) continue;
                    }

                    if (canMove(board, fromRow, fromCol, toRow, toCol, pieceType, isWhite)) {
                        moves.push({ fromRow, fromCol, toRow, toCol, piece });
                    }
                }
            }

            // Add castling moves
            if (pieceType === 'K') {
                const row = isWhite ? 7 : 0;
                if (fromRow === row && fromCol === 4) {
                    // Kingside
                    if (board[row][7] === (isWhite ? 'R' : 'r') &&
                        !board[row][5] && !board[row][6]) {
                        moves.push({ fromRow, fromCol, toRow: row, toCol: 6, piece, castling: 'K' });
                    }
                    // Queenside
                    if (board[row][0] === (isWhite ? 'R' : 'r') &&
                        !board[row][1] && !board[row][2] && !board[row][3]) {
                        moves.push({ fromRow, fromCol, toRow: row, toCol: 2, piece, castling: 'Q' });
                    }
                }
            }

            return moves;
        }

        // Execute a move
        function executeMove(move) {
            // Enter analysis mode if not already
            if (!analysisMode) {
                analysisMode = true;
                analysisBoard = copyBoard(getCurrentBoard());
                analysisWhiteToMove = (currentMoveIndex + 1) % 2 === 0;
                analysisControls.classList.remove('hidden');
                analysisBadge.classList.remove('hidden');
            }

            const board = analysisBoard;
            const { fromRow, fromCol, toRow, toCol, piece, castling } = move;

            // Handle castling
            if (castling) {
                const row = fromRow;
                if (castling === 'K') {
                    board[row][6] = board[row][4];
                    board[row][5] = board[row][7];
                    board[row][4] = null;
                    board[row][7] = null;
                } else {
                    board[row][2] = board[row][4];
                    board[row][3] = board[row][0];
                    board[row][4] = null;
                    board[row][0] = null;
                }
            } else {
                // Check for pawn promotion
                const pieceType = piece.toUpperCase();
                if (pieceType === 'P' && (toRow === 0 || toRow === 7)) {
                    showPromotionDialog(fromRow, fromCol, toRow, toCol, analysisWhiteToMove);
                    return;
                }

                // En passant capture
                if (pieceType === 'P' && fromCol !== toCol && !board[toRow][toCol]) {
                    board[fromRow][toCol] = null;
                }

                board[toRow][toCol] = piece;
                board[fromRow][fromCol] = null;
            }

            analysisWhiteToMove = !analysisWhiteToMove;
            updateTurnIndicator();

            // Trigger analysis
            if (engineEnabled) {
                analyzeCurrentPosition();
            }
        }

        // Show promotion dialog
        function showPromotionDialog(fromRow, fromCol, toRow, toCol, isWhite) {
            const pieces = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            const promotionPieces = document.getElementById('promotionPieces');

            promotionPieces.innerHTML = pieces.map(p => `
                <div class="promotion-piece ${PIECE_CLASSES[p]}" data-piece="${p}"></div>
            `).join('');

            promotionModal.classList.remove('hidden');

            promotionPieces.querySelectorAll('.promotion-piece').forEach(el => {
                el.addEventListener('click', () => {
                    const promotedPiece = el.dataset.piece;
                    analysisBoard[toRow][toCol] = promotedPiece;
                    analysisBoard[fromRow][fromCol] = null;
                    analysisWhiteToMove = !analysisWhiteToMove;
                    promotionModal.classList.add('hidden');
                    updateTurnIndicator();
                    renderBoard(analysisBoard);
                    if (engineEnabled) {
                        analyzeCurrentPosition();
                    }
                });
            });
        }

        // Update turn indicator
        function updateTurnIndicator() {
            const turnIndicator = document.getElementById('turnIndicator');
            if (!turnIndicator) return;

            const isWhiteToMove = analysisMode ? analysisWhiteToMove : ((currentMoveIndex + 1) % 2 === 0);

            if (isWhiteToMove) {
                turnIndicator.className = 'turn-indicator white';
                turnIndicator.innerHTML = '<span class="turn-dot"></span><span>White to move</span>';
            } else {
                turnIndicator.className = 'turn-indicator black';
                turnIndicator.innerHTML = '<span class="turn-dot"></span><span>Black to move</span>';
            }
        }

        // Reset to game position
        function resetToGamePosition() {
            analysisMode = false;
            analysisBoard = null;
            selectedSquare = null;
            validMoves = [];
            analysisControls.classList.add('hidden');
            analysisBadge.classList.add('hidden');

            // Only render board from history if a game is loaded
            if (boardHistory && boardHistory[currentMoveIndex + 1]) {
                const historyEntry = boardHistory[currentMoveIndex + 1];
                renderBoard(historyEntry.board, historyEntry.moveSquares);
                updateTurnIndicator();

                if (engineEnabled) {
                    analyzeCurrentPosition();
                }
            }
        }

        // Async PGN Parser
        async function parsePGNAsync(pgnText) {
            return new Promise((resolve) => {
                showLoading(true, 0, 'Parsing PGN file...', 'Splitting games...');

                setTimeout(() => {
                    const gameTexts = pgnText.split(/\n(?=\[Event\s)/);
                    const totalGames = gameTexts.length;
                    const parsedGames = [];
                    let currentIndex = 0;
                    const chunkSize = 100;

                    function processChunk() {
                        const end = Math.min(currentIndex + chunkSize, totalGames);

                        for (let i = currentIndex; i < end; i++) {
                            const gameText = gameTexts[i];
                            if (!gameText.trim()) continue;

                            try {
                                const game = parseGameText(gameText);
                                if (game && game.moves.length > 0) {
                                    game.index = parsedGames.length;
                                    parsedGames.push(game);
                                }
                            } catch (e) {
                                console.warn('Failed to parse game', i, e);
                            }
                        }

                        currentIndex = end;
                        const progress = Math.round((currentIndex / totalGames) * 100);
                        updateProgress(progress, 'Parsing games...', `${parsedGames.length} games parsed (${currentIndex}/${totalGames})`);

                        if (currentIndex < totalGames) {
                            setTimeout(processChunk, 0);
                        } else {
                            showLoading(false);
                            resolve(parsedGames);
                        }
                    }

                    processChunk();
                }, 50);
            });
        }

        // Parse single game
        function parseGameText(gameText) {
            const game = { headers: {}, moves: [], rawMoves: '' };

            const headerRegex = /\[(\w+)\s+"([^"]*)"\]/g;
            let match;
            while ((match = headerRegex.exec(gameText)) !== null) {
                game.headers[match[1]] = match[2];
            }

            let movesText = gameText.replace(/\[[^\]]+\]/g, '').trim();

            let prevLength;
            do {
                prevLength = movesText.length;
                movesText = movesText.replace(/\([^()]*\)/g, '');
            } while (movesText.length !== prevLength);

            movesText = movesText.replace(/\{[^}]*\}/g, '');
            movesText = movesText.replace(/\$\d+/g, '');
            movesText = movesText.replace(/\d+\.{1,3}\s*/g, ' ');
            movesText = movesText.replace(/1-0|0-1|1\/2-1\/2|\*/g, '');
            movesText = movesText.replace(/\s+/g, ' ').trim();

            game.rawMoves = movesText;
            game.moves = movesText.split(/\s+/).filter(m => m.length > 0 && m.match(/^[KQRBN]?[a-h]?[1-8]?x?[a-h][1-8](=[QRBN])?[+#]?$|^O-O(-O)?[+#]?$/i));

            return game;
        }

        // Deep copy board
        function copyBoard(board) {
            return board.map(row => [...row]);
        }

        // Parse algebraic notation and apply move
        function applyMove(board, move, isWhite) {
            const newBoard = copyBoard(board);
            let fromRow, fromCol, toRow, toCol;
            let moveSquares = [];

            // Castling
            if (move === 'O-O' || move === 'O-O-O' || move === 'O-O+' || move === 'O-O#' || move === 'O-O-O+' || move === 'O-O-O#') {
                const row = isWhite ? 7 : 0;
                const isKingside = move.startsWith('O-O') && !move.startsWith('O-O-O');

                if (isKingside) {
                    newBoard[row][6] = newBoard[row][4];
                    newBoard[row][5] = newBoard[row][7];
                    newBoard[row][4] = null;
                    newBoard[row][7] = null;
                    moveSquares = [`${row},4`, `${row},6`];
                } else {
                    newBoard[row][2] = newBoard[row][4];
                    newBoard[row][3] = newBoard[row][0];
                    newBoard[row][4] = null;
                    newBoard[row][0] = null;
                    moveSquares = [`${row},4`, `${row},2`];
                }
                return { board: newBoard, moveSquares };
            }

            let cleanMove = move.replace(/[+#!?]/g, '');

            let promotionPiece = null;
            if (cleanMove.includes('=')) {
                const parts = cleanMove.split('=');
                cleanMove = parts[0];
                promotionPiece = isWhite ? parts[1][0].toUpperCase() : parts[1][0].toLowerCase();
            }

            let pieceType = 'P';
            if (['K', 'Q', 'R', 'B', 'N'].includes(cleanMove[0])) {
                pieceType = cleanMove[0];
                cleanMove = cleanMove.substring(1);
            }

            const pieceChar = isWhite ? pieceType : pieceType.toLowerCase();

            cleanMove = cleanMove.replace('x', '');

            const targetMatch = cleanMove.match(/([a-h])([1-8])$/);
            if (!targetMatch) return { board: newBoard, moveSquares: [] };

            toCol = targetMatch[1].charCodeAt(0) - 97;
            toRow = 8 - parseInt(targetMatch[2]);

            const disambig = cleanMove.replace(/[a-h][1-8]$/, '');

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (newBoard[r][c] === pieceChar) {
                        if (disambig.length > 0) {
                            const fileMatch = disambig.match(/[a-h]/);
                            const rankMatch = disambig.match(/[1-8]/);
                            if (fileMatch && c !== fileMatch[0].charCodeAt(0) - 97) continue;
                            if (rankMatch && r !== 8 - parseInt(rankMatch[0])) continue;
                        }

                        if (canMove(newBoard, r, c, toRow, toCol, pieceType, isWhite)) {
                            fromRow = r;
                            fromCol = c;
                            break;
                        }
                    }
                }
                if (fromRow !== undefined) break;
            }

            if (fromRow !== undefined) {
                if (pieceType === 'P' && fromCol !== toCol && newBoard[toRow][toCol] === null) {
                    newBoard[fromRow][toCol] = null;
                }

                newBoard[toRow][toCol] = promotionPiece || pieceChar;
                newBoard[fromRow][fromCol] = null;
                moveSquares = [`${fromRow},${fromCol}`, `${toRow},${toCol}`];
            }

            return { board: newBoard, moveSquares };
        }

        function canMove(board, fromRow, fromCol, toRow, toCol, pieceType, isWhite) {
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;

            switch (pieceType) {
                case 'P':
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 6 : 1;
                    if (colDiff === 0) {
                        if (rowDiff === direction && !board[toRow][toCol]) return true;
                        if (fromRow === startRow && rowDiff === 2 * direction && !board[toRow][toCol] && !board[fromRow + direction][fromCol]) return true;
                    }
                    if (Math.abs(colDiff) === 1 && rowDiff === direction) {
                        // Capture or en passant
                        if (board[toRow][toCol]) return true;
                        // En passant (simplified check)
                        if (!board[toRow][toCol] && board[fromRow][toCol]) return true;
                    }
                    return false;

                case 'N':
                    return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) ||
                        (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);

                case 'B':
                    if (Math.abs(rowDiff) !== Math.abs(colDiff)) return false;
                    return isPathClear(board, fromRow, fromCol, toRow, toCol);

                case 'R':
                    if (rowDiff !== 0 && colDiff !== 0) return false;
                    return isPathClear(board, fromRow, fromCol, toRow, toCol);

                case 'Q':
                    if (rowDiff !== 0 && colDiff !== 0 && Math.abs(rowDiff) !== Math.abs(colDiff)) return false;
                    return isPathClear(board, fromRow, fromCol, toRow, toCol);

                case 'K':
                    return Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1;

                default:
                    return false;
            }
        }

        function isPathClear(board, fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : (toRow < fromRow ? -1 : 0);
            const colStep = toCol > fromCol ? 1 : (toCol < fromCol ? -1 : 0);

            let r = fromRow + rowStep;
            let c = fromCol + colStep;

            while (r !== toRow || c !== toCol) {
                if (board[r][c] !== null) return false;
                r += rowStep;
                c += colStep;
            }
            return true;
        }

        function generateBoardHistory(game) {
            boardHistory = [{ board: copyBoard(INITIAL_BOARD), moveSquares: null }];
            let currentBoard = copyBoard(INITIAL_BOARD);

            for (let i = 0; i < game.moves.length; i++) {
                const isWhite = i % 2 === 0;
                const result = applyMove(currentBoard, game.moves[i], isWhite);
                currentBoard = result.board;
                boardHistory.push({ board: copyBoard(currentBoard), moveSquares: result.moveSquares });
            }
        }

        function filterGames(query) {
            if (!query.trim()) {
                filteredGames = [...games];
            } else {
                const q = query.toLowerCase();
                filteredGames = games.filter(game => {
                    const white = (game.headers.White || '').toLowerCase();
                    const black = (game.headers.Black || '').toLowerCase();
                    const event = (game.headers.Event || '').toLowerCase();
                    const site = (game.headers.Site || '').toLowerCase();
                    const date = (game.headers.Date || '').toLowerCase();
                    return white.includes(q) || black.includes(q) || event.includes(q) || site.includes(q) || date.includes(q);
                });
            }
            currentPage = 0;
            updateGamesList();
            updatePagination();
        }

        function updateGamesList() {
            if (filteredGames.length === 0) {
                gamesList.innerHTML = '<p class="text-slate-500 text-sm text-center py-4">No games found</p>';
                gamesCount.textContent = '';
                return;
            }

            gamesCount.textContent = `(${filteredGames.length})`;

            const start = currentPage * GAMES_PER_PAGE;
            const end = Math.min(start + GAMES_PER_PAGE, filteredGames.length);
            const pageGames = filteredGames.slice(start, end);

            gamesList.innerHTML = pageGames.map((game) => {
                const white = game.headers.White || 'Unknown';
                const black = game.headers.Black || 'Unknown';
                const result = game.headers.Result || '*';
                const date = game.headers.Date || '';
                const year = date.split('.')[0] || '';
                const isActive = game.index === currentGameIndex;

                return `
                    <div class="game-card p-3 rounded-lg ${isActive ? 'active' : ''}" 
                         onclick="selectGame(${game.index})">
                        <div class="flex justify-between items-start">
                            <div class="flex-1 min-w-0">
                                <div class="font-medium text-sm truncate flex items-center gap-1">
                                    <span class="piece-icon-sm piece-wK"></span> ${white}
                                </div>
                                <div class="font-medium text-sm truncate flex items-center gap-1">
                                    <span class="piece-icon-sm piece-bK"></span> ${black}
                                </div>
                            </div>
                            <div class="text-xs text-slate-400 ml-2">#${game.index + 1}</div>
                        </div>
                        <div class="text-xs text-slate-400 mt-1">${result} ${year ? '‚Ä¢ ' + year : ''}</div>
                    </div>
                `;
            }).join('');
        }

        function updatePagination() {
            const totalPages = Math.ceil(filteredGames.length / GAMES_PER_PAGE);

            if (totalPages <= 1) {
                pagination.classList.add('hidden');
                jumpToGame.classList.add('hidden');
                return;
            }

            pagination.classList.remove('hidden');
            jumpToGame.classList.remove('hidden');

            prevPage.disabled = currentPage === 0;
            nextPage.disabled = currentPage >= totalPages - 1;
            pageInfo.textContent = `Page ${currentPage + 1} / ${totalPages}`;
        }

        function updateMovesList() {
            const game = games[currentGameIndex];
            if (!game || game.moves.length === 0) {
                movesList.innerHTML = '<p class="text-slate-500 text-sm text-center py-4">No moves to display</p>';
                return;
            }

            let html = '<div class="grid grid-cols-2 gap-1 text-sm">';
            for (let i = 0; i < game.moves.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const whiteMove = game.moves[i];
                const blackMove = game.moves[i + 1] || '';

                html += `
                    <div class="move-item ${i === currentMoveIndex ? 'active' : ''}" onclick="goToMove(${i})">
                        ${moveNum}. ${whiteMove}
                    </div>
                    ${blackMove ? `
                        <div class="move-item ${i + 1 === currentMoveIndex ? 'active' : ''}" onclick="goToMove(${i + 1})">
                            ${blackMove}
                        </div>
                    ` : '<div></div>'}
                `;
            }
            html += '</div>';
            movesList.innerHTML = html;
        }

        function updateGameInfo() {
            const game = games[currentGameIndex];
            if (!game) {
                gameInfo.classList.add('hidden'); // Hide when no game
                return;
            }

            // Show game info when a game is loaded
            gameInfo.classList.remove('hidden');

            const h = game.headers;
            gameInfo.innerHTML = `
                <div class="flex justify-between items-center mb-3">
                    <div class="flex items-center gap-3">
                        <div class="player-badge white">
                            <span class="piece-icon-sm piece-wK" style="width:24px;height:24px;"></span>
                        </div>
                        <div>
                            <div class="font-semibold">${h.White || 'Unknown'}</div>
                            <div class="text-xs text-slate-400">${h.WhiteElo || '?'}</div>
                        </div>
                    </div>
                    <div class="text-xl font-bold px-4 py-1 bg-slate-700 rounded-lg">${h.Result || '*'}</div>
                    <div class="flex items-center gap-3">
                        <div class="text-right">
                            <div class="font-semibold">${h.Black || 'Unknown'}</div>
                            <div class="text-xs text-slate-400">${h.BlackElo || '?'}</div>
                        </div>
                        <div class="player-badge black">
                            <span class="piece-icon-sm piece-bK" style="width:24px;height:24px;"></span>
                        </div>
                    </div>
                </div>
                <div class="text-center text-xs text-slate-400">
                    ${h.Event || ''} ${h.Site ? '‚Ä¢ ' + h.Site : ''} ${h.Date ? '‚Ä¢ ' + h.Date : ''}
                </div>
            `;
        }

        function updateMoveCounter() {
            const game = games[currentGameIndex];
            const total = game ? game.moves.length : 0;
            moveCounter.textContent = `${currentMoveIndex + 1} / ${total}`;
        }

        function updateGameCounter() {
            if (currentGameIndex === -1) {
                gameCounter.textContent = `No game / ${games.length}`;
            } else {
                gameCounter.textContent = `Game ${currentGameIndex + 1} / ${games.length}`;
            }
        }

        function selectGame(index) {
            stopAutoPlay();

            // Only reset analysis if we are actually in analysis mode
            if (analysisMode) {
                resetToGamePosition();
            }

            currentGameIndex = index;
            currentMoveIndex = -1;

            // Ensure we have a valid game before generating history
            if (games[index]) {
                generateBoardHistory(games[index]);
                updateGamesList();
                updateMovesList();
                updateGameInfo();
                renderBoard(boardHistory[0].board);
                updateMoveCounter();
                updateGameCounter();
                updateTurnIndicator();

                const activeCard = gamesList.querySelector('.game-card.active');
                if (activeCard) {
                    activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }

                if (engineEnabled) {
                    analyzeCurrentPosition();
                }
            }
        }

        // Expose selectGame globally for onclick handlers
        window.selectGame = selectGame;

        function goToMove(index) {
            stopAutoPlay();
            if (analysisMode) {
                resetToGamePosition();
            }
            currentMoveIndex = index;
            selectedSquare = null;
            validMoves = [];
            const historyEntry = boardHistory[index + 1];
            renderBoard(historyEntry.board, historyEntry.moveSquares);
            updateMovesList();
            updateMoveCounter();
            updateTurnIndicator();

            if (engineEnabled) {
                analyzeCurrentPosition();
            }
        }

        function goToFirst() {
            stopAutoPlay();
            if (analysisMode) {
                resetToGamePosition();
            }
            currentMoveIndex = -1;
            selectedSquare = null;
            validMoves = [];
            renderBoard(boardHistory[0].board);
            updateMovesList();
            updateMoveCounter();
            updateTurnIndicator();

            if (engineEnabled) {
                analyzeCurrentPosition();
            }
        }

        function goToPrev() {
            if (currentMoveIndex >= 0) {
                if (analysisMode) {
                    resetToGamePosition();
                }
                currentMoveIndex--;
                selectedSquare = null;
                validMoves = [];
                const historyEntry = boardHistory[currentMoveIndex + 1];
                renderBoard(historyEntry.board, historyEntry.moveSquares);
                updateMovesList();
                updateMoveCounter();
                updateTurnIndicator();

                if (engineEnabled) {
                    analyzeCurrentPosition();
                }
            }
        }

        function goToNext() {
            const game = games[currentGameIndex];
            if (game && currentMoveIndex < game.moves.length - 1) {
                if (analysisMode) {
                    resetToGamePosition();
                }
                currentMoveIndex++;
                selectedSquare = null;
                validMoves = [];
                const historyEntry = boardHistory[currentMoveIndex + 1];
                renderBoard(historyEntry.board, historyEntry.moveSquares);
                updateMovesList();
                updateMoveCounter();
                updateTurnIndicator();

                if (engineEnabled) {
                    analyzeCurrentPosition();
                }
            }
        }

        function goToLast() {
            stopAutoPlay();
            if (analysisMode) {
                resetToGamePosition();
            }
            const game = games[currentGameIndex];
            if (game) {
                currentMoveIndex = game.moves.length - 1;
                selectedSquare = null;
                validMoves = [];
                const historyEntry = boardHistory[currentMoveIndex + 1];
                renderBoard(historyEntry.board, historyEntry.moveSquares);
                updateMovesList();
                updateMoveCounter();
                updateTurnIndicator();

                if (engineEnabled) {
                    analyzeCurrentPosition();
                }
            }
        }

        function goToPrevGame() {
            if (currentGameIndex > 0) {
                selectGame(currentGameIndex - 1);
            } else if (currentGameIndex === -1 && games.length > 0) {
                // If no game selected, go to last game
                selectGame(games.length - 1);
            }
        }

        function goToNextGame() {
            if (currentGameIndex < games.length - 1 && currentGameIndex >= 0) {
                selectGame(currentGameIndex + 1);
            } else if (currentGameIndex === -1 && games.length > 0) {
                // If no game selected, go to first game
                selectGame(0);
            }
        }

        function toggleAutoPlay() {
            const btn = document.getElementById('btnAutoPlay');
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                if (analysisMode) {
                    resetToGamePosition();
                }
                const speed = parseInt(document.getElementById('playSpeed').value);
                document.getElementById('btnAutoPlayIcon').innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5" fill="currentColor" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
                btn.querySelector('span:last-child').textContent = 'Pause';
                btn.classList.remove('from-green-500', 'to-emerald-500', 'hover:from-green-600', 'hover:to-emerald-600');
                btn.classList.add('from-orange-500', 'to-red-500', 'hover:from-orange-600', 'hover:to-red-600');
                autoPlayInterval = setInterval(() => {
                    const game = games[currentGameIndex];
                    if (game && currentMoveIndex < game.moves.length - 1) {
                        goToNext();
                    } else {
                        stopAutoPlay();
                    }
                }, speed);
            }
        }

        function stopAutoPlay() {
            const btn = document.getElementById('btnAutoPlay');
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                document.getElementById('btnAutoPlayIcon').innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2.5" fill="currentColor" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
                btn.querySelector('span:last-child').textContent = 'Auto';
                btn.classList.add('from-green-500', 'to-emerald-500', 'hover:from-green-600', 'hover:to-emerald-600');
                btn.classList.remove('from-orange-500', 'to-red-500', 'hover:from-orange-600', 'hover:to-red-600');
            }
        }

        async function handleFile(file) {
            showLoading(true, 0, 'Reading file...', file.name);

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const content = e.target.result;
                    games = await parsePGNAsync(content);

                    if (games.length > 0) {
                        filteredGames = [...games];
                        currentPage = 0;

                        // Update the games list but don't auto-select any game
                        updateGamesList();
                        updatePagination();
                        updateGameCounter();

                        // Reset board to initial position without loading a game
                        currentGameIndex = -1;
                        currentMoveIndex = -1;
                        initBoard();
                        renderBoard(INITIAL_BOARD);
                        updateMoveCounter();
                        updateGameInfo(); // Will hide game info since no game is selected
                    } else {
                        alert('No valid games found in the PGN file.');
                    }
                } catch (error) {
                    console.error('Error parsing PGN:', error);
                    alert('Error parsing PGN file. Please check the file format.');
                    showLoading(false);
                }
            };
            reader.onerror = () => {
                alert('Error reading file.');
                showLoading(false);
            };
            reader.readAsText(file);
        }

        // Event Listeners
        document.getElementById('btnFirst').addEventListener('click', goToFirst);
        document.getElementById('btnPrev').addEventListener('click', goToPrev);
        document.getElementById('btnNext').addEventListener('click', goToNext);
        document.getElementById('btnLast').addEventListener('click', goToLast);
        document.getElementById('btnPrevGame').addEventListener('click', goToPrevGame);
        document.getElementById('btnNextGame').addEventListener('click', goToNextGame);
        document.getElementById('btnAutoPlay').addEventListener('click', toggleAutoPlay);
        document.getElementById('btnResetBoard').addEventListener('click', () => {
            try {
                // Stop autoplay if running
                if (typeof isAutoPlaying !== 'undefined' && isAutoPlaying) toggleAutoPlay();

                // Reset game state
                currentGameIndex = -1;
                currentMoveIndex = -1;

                // Safety check for INITIAL_BOARD and copyBoard
                const initialBoard = (typeof INITIAL_BOARD !== 'undefined') ? INITIAL_BOARD : [];
                const boardCopy = (typeof copyBoard === 'function') ? copyBoard(initialBoard) : JSON.parse(JSON.stringify(initialBoard));

                boardHistory = [{ board: boardCopy, move: null }];

                // Reset analysis/edit state
                analysisMode = false;
                analysisBoard = null;
                undoHistory = [];
                if (typeof updateUndoButton === 'function') updateUndoButton();

                // Reset selection
                selectedSquare = null;
                draggedPiece = null;
                draggedFrom = null;

                // Reset UI
                renderBoard(initialBoard);
                if (typeof updateMoveCounter === 'function') updateMoveCounter();
                if (typeof updateGameCounter === 'function') updateGameCounter();
                if (typeof updateGameInfo === 'function') updateGameInfo();

                // Clear analysis if engine is on
                if (engineEnabled && typeof analyzeCurrentPosition === 'function') {
                    analyzeCurrentPosition();
                }
            } catch (error) {
                console.error('Error resetting board:', error);
            }
        });
        document.getElementById('btnResetPosition').addEventListener('click', resetToGamePosition);

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterGames(e.target.value);
            }, 300);
        });

        prevPage.addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                updateGamesList();
                updatePagination();
            }
        });

        nextPage.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredGames.length / GAMES_PER_PAGE);
            if (currentPage < totalPages - 1) {
                currentPage++;
                updateGamesList();
                updatePagination();
            }
        });

        document.getElementById('jumpBtn').addEventListener('click', () => {
            const jumpInput = document.getElementById('jumpInput');
            const gameNum = parseInt(jumpInput.value);
            if (gameNum >= 1 && gameNum <= games.length) {
                selectGame(gameNum - 1);
                jumpInput.value = '';
            }
        });

        document.getElementById('jumpInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('jumpBtn').click();
            }
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                goToPrev();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                goToNext();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                goToPrevGame();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                goToNextGame();
            } else if (e.key === 'Home') {
                e.preventDefault();
                goToFirst();
            } else if (e.key === 'End') {
                e.preventDefault();
                goToLast();
            } else if (e.key === ' ') {
                e.preventDefault();
                toggleAutoPlay();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                if (analysisMode) {
                    resetToGamePosition();
                }
                selectedSquare = null;
                validMoves = [];
                renderBoard(getCurrentBoard());
            }
        });

        // Initialize
        initBoard();
        renderBoard(INITIAL_BOARD);

        //         // Load sample PGN for demo
        //         const samplePGN = `[Event "Troll Masters"]
        // [Site "Gausdal NOR"]
        // [Date "2001.01.05"]
        // [Round "1"]
        // [White "Edvardsen,R"]
        // [Black "Carlsen,Magnus"]
        // [Result "1/2-1/2"]
        // [WhiteElo "2055"]
        // [BlackElo ""]
        // [ECO "D12"]

        // 1.d4 Nf6 2.Nf3 d5 3.e3 Bf5 4.c4 c6 5.Nc3 e6 6.Bd3 Bxd3 7.Qxd3 Nbd7 8.b3 Bd6
        // 9.O-O O-O 10.Bb2 Qe7 11.Rad1 Rad8 12.Rfe1 dxc4 13.bxc4 e5 14.dxe5 Nxe5 15.Nxe5 Bxe5
        // 16.Qe2 Rxd1 17.Rxd1 Rd8 18.Rxd8+ Qxd8 19.Qd1 Qxd1+ 20.Nxd1 Bxb2 21.Nxb2 b5
        // 22.f3 Kf8 23.Kf2 Ke7  1/2-1/2

        // [Event "Troll Masters"]
        // [Site "Gausdal NOR"]
        // [Date "2001.01.06"]
        // [Round "2"]
        // [White "Carlsen,Magnus"]
        // [Black "Brameld,A"]
        // [Result "0-1"]
        // [WhiteElo ""]
        // [BlackElo "2095"]
        // [ECO "B05"]

        // 1.e4 Nf6 2.e5 Nd5 3.d4 d6 4.Nf3 Bg4 5.Bc4 e6 6.O-O Nb6 7.Be2 Be7 8.h3 Bh5
        // 9.Bf4 Nc6 10.c3 O-O 11.Nbd2 d5 12.b4 a5 13.a3 Qd7 14.Qc2 Bg6 15.Bd3 Rfc8
        // 16.Rfb1 Bf8 17.h4 Ne7 18.g3 Qa4 19.Ne1 Qxc2 20.Bxc2 Bxc2 21.Nxc2 Na4 22.Rb3 b6
        // 23.Kf1 c5 24.bxc5 bxc5 25.dxc5 Rxc5 26.Nb1 Rac8 27.Be3 Rc4 28.Bd4 Nc6 29.Rb5 Nxd4
        // 30.Nxd4 Nxc3 31.Nxc3 Rxd4 32.Ne2 Ra4 33.Ke1 Rxa3 34.Rab1 Bb4+ 35.Kf1 Rd3  0-1`;

        // games = samplePGN.split(/\n(?=\[Event\s)/).map((text, i) => {
        //     const game = parseGameText(text);
        //     game.index = i;
        //     return game;
        // }).filter(g => g.moves.length > 0);

        // Initialize with no game selected, just show the initial board
        if (games.length > 0) {
            filteredGames = [...games];
            updateGamesList();
            updatePagination();
        }
        updateGameCounter();
        updateGameInfo();

        // ==================== STOCKFISH ENGINE ====================

        let stockfish = null;
        let engineEnabled = false;
        let engineReady = false;
        let isAnalyzing = false;
        let currentAnalysisSide = null;
        let analysisBySide = { white: {}, black: {} };
        let lastAnalyzedFen = '';
        let currentAnalysisId = 0; // Track analysis requests to cancel outdated ones
        let activeAnalysisId = 0; // Track the currently executing analysis ID
        let analysisTimeout = null; // For debouncing rapid position changes

        // DOM elements for engine
        const engineToggle = document.getElementById('engineToggle');
        const engineStatus = document.getElementById('engineStatus');
        const engineSettings = document.getElementById('engineSettings');
        const engineLoading = document.getElementById('engineLoading');
        const engineOffState = document.getElementById('engineOffState');
        const analysisDisplay = document.getElementById('analysisDisplay');
        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        const multiPV = document.getElementById('multiPV');
        const evalFillWhite = document.getElementById('evalFillWhite');
        const evalScoreBarWhite = document.getElementById('evalScoreBarWhite');
        const currentDepthWhite = document.getElementById('currentDepthWhite');
        const bestMoveWhite = document.getElementById('bestMoveWhite');
        const analysisLinesWhite = document.getElementById('analysisLinesWhite');
        const thinkingIndicatorWhite = document.getElementById('thinkingIndicatorWhite');
        const evalInlineWhiteLeftFill = document.getElementById('evalInlineWhiteLeftFill');
        const evalInlineWhiteRightFill = document.getElementById('evalInlineWhiteRightFill');
        const evalInlineWhiteLabel = document.getElementById('evalInlineWhiteLabel');
        const evalFillBlack = document.getElementById('evalFillBlack');
        const evalScoreBarBlack = document.getElementById('evalScoreBarBlack');
        const currentDepthBlack = document.getElementById('currentDepthBlack');
        const bestMoveBlack = document.getElementById('bestMoveBlack');
        const analysisLinesBlack = document.getElementById('analysisLinesBlack');
        const thinkingIndicatorBlack = document.getElementById('thinkingIndicatorBlack');
        const evalInlineBlackLeftFill = document.getElementById('evalInlineBlackLeftFill');
        const evalInlineBlackRightFill = document.getElementById('evalInlineBlackRightFill');
        const evalInlineBlackLabel = document.getElementById('evalInlineBlackLabel');

        // Convert board array to FEN string
        function boardToFEN(board, isWhiteToMove) {
            let fen = '';

            for (let row = 0; row < 8; row++) {
                let emptyCount = 0;
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece === null) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        fen += piece;
                    }
                }
                if (emptyCount > 0) {
                    fen += emptyCount;
                }
                if (row < 7) fen += '/';
            }

            fen += isWhiteToMove ? ' w' : ' b';
            fen += ' KQkq';
            fen += ' -';
            fen += ' 0 1';

            return fen;
        }

        // Engine version file mappings
        const ENGINE_VERSIONS = {
            'lite-single': './sockfish/stockfish-17.1-lite-single-03e3232.js',
            'large-single': './sockfish/stockfish-17.1-single-a496a04.js'
        };

        const engineVersionSelect = document.getElementById('engineVersionSelect');
        const engineVersionSelector = document.getElementById('engineVersionSelector');

        function getStockfishSource() {
            const version = engineVersionSelect.value;
            return ENGINE_VERSIONS[version] || ENGINE_VERSIONS['lite-single'];
        }

        async function initStockfish() {
            if (stockfish) return;

            engineLoading.classList.remove('hidden');
            engineOffState.classList.add('hidden');
            engineVersionSelector.classList.add('hidden'); // Hide selector while loading
            engineStatus.textContent = 'Loading...';

            const source = getStockfishSource();
            const versionName = engineVersionSelect.options[engineVersionSelect.selectedIndex].text;
            engineStatus.textContent = `Loading ${versionName.split('(')[0].trim()}...`;

            try {
                const success = await tryLoadStockfish(source);
                if (success) {
                    console.log('Stockfish loaded from:', source);
                    return;
                }
            } catch (error) {
                console.warn(`Failed to load from ${source}:`, error);
            }

            // Failed to load
            console.error('Failed to load Stockfish engine');
            engineStatus.textContent = 'Failed to load';
            engineLoading.classList.add('hidden');
            engineOffState.classList.remove('hidden');
            engineVersionSelector.classList.remove('hidden'); // Show selector again on failure
            engineEnabled = false;
            engineToggle.classList.remove('active');

            const isFileProtocol = window.location.protocol === 'file:';
            let errorMessage = 'Failed to load engine. Try a different version.';

            if (isFileProtocol) {
                errorMessage += '\n\nIMPORTANT: It looks like you are opening this page as a local file (file://).\n' +
                    'Browsers block Web Workers and WASM when loaded this way for security.\n\n' +
                    'To fix this, please run a local web server. For example, run this in your terminal:\n' +
                    'python3 -m http.server\n\n' +
                    'Then open http://localhost:8000 in your browser.';
            } else {
                errorMessage += '\n\nMulti-threaded versions require CORS headers.\n' +
                    'Try Single-threaded if you\'re not using a proper web server.';
            }

            alert(errorMessage);
        }

        function tryLoadStockfish(url) {
            return new Promise((resolve, reject) => {
                try {
                    // Load worker directly from URL (not blob) so relative WASM paths work
                    stockfish = new Worker(url);

                    let initialized = false;
                    const timeout = setTimeout(() => {
                        if (!initialized) {
                            stockfish.terminate();
                            stockfish = null;
                            reject(new Error('Timeout - engine took too long to initialize'));
                        }
                    }, 30000); // 30 second timeout for large engines

                    stockfish.onmessage = (e) => {
                        const message = e.data;

                        if (message === 'uciok' && !initialized) {
                            initialized = true;
                            clearTimeout(timeout);
                            resolve(true);
                        }

                        handleStockfishMessage(message);
                    };

                    stockfish.onerror = (e) => {
                        clearTimeout(timeout);
                        console.error('Stockfish worker error:', e);
                        if (!initialized) {
                            stockfish.terminate();
                            stockfish = null;
                            reject(new Error('Worker failed to load'));
                        } else {
                            engineStatus.textContent = 'Error';
                            engineEnabled = false;
                            engineToggle.classList.remove('active');
                        }
                    };

                    stockfish.postMessage('uci');

                } catch (error) {
                    console.error('Failed to create worker:', error);
                    reject(error);
                }
            });
        }


        function handleStockfishMessage(message) {
            // Capture Stockfish version from the id message
            if (message.startsWith('id name')) {
                // Extract version like "10" from "Stockfish 10" or similar
                const versionMatch = message.match(/Stockfish\s+([^\s]+)/i);
                if (versionMatch) {
                    const engineVersionEl = document.getElementById('engineVersion');
                    if (engineVersionEl) {
                        const selectedVersion = engineVersionSelect.value;
                        const versionType = selectedVersion.includes('large') ? 'Strong' : 'Lite';
                        engineVersionEl.textContent = `v${versionMatch[1]} ${versionType}`;
                    }
                }
            }

            if (message === 'uciok') {
                engineReady = true;
                stockfish.postMessage('setoption name MultiPV value ' + multiPV.value);
                stockfish.postMessage('isready');
            }

            if (message === 'readyok') {
                engineLoading.classList.add('hidden');
                engineSettings.classList.remove('hidden');
                analysisDisplay.classList.remove('hidden');
                engineStatus.textContent = 'On';

                analyzeCurrentPosition();
            }

            if (message.startsWith('info depth')) {
                parseAnalysisInfo(message);
            }

            if (message.startsWith('bestmove')) {
                // Only process moves for the current active analysis
                if (activeAnalysisId !== currentAnalysisId) return;

                if (currentAnalysisSide === 'white') {
                    const board = getCurrentBoard();
                    const fenBlack = boardToFEN(board, false);
                    currentAnalysisSide = 'black';
                    stockfish.postMessage('position fen ' + fenBlack);
                    stockfish.postMessage('go depth ' + depthSlider.value);
                } else {
                    isAnalyzing = false;
                    thinkingIndicatorWhite.classList.add('hidden');
                    thinkingIndicatorBlack.classList.add('hidden');
                }
            }
        }

        function parseAnalysisInfo(info) {
            if (!isAnalyzing || !currentAnalysisSide) return;
            const depthMatch = info.match(/depth (\d+)/);
            const pvMatch = info.match(/multipv (\d+)/);
            const scoreMatch = info.match(/score (cp|mate) (-?\d+)/);
            const pvMovesMatch = info.match(/ pv (.+)/);
            if (!depthMatch || !scoreMatch) return;
            const depth = parseInt(depthMatch[1]);
            const pvNum = pvMatch ? parseInt(pvMatch[1]) : 1;
            const scoreType = scoreMatch[1];
            const scoreValue = parseInt(scoreMatch[2]);
            const pvMoves = pvMovesMatch ? pvMovesMatch[1].split(' ').slice(0, 8) : [];
            let evalValue;
            let evalText;
            const isWhiteToMove = currentAnalysisSide === 'white';
            if (scoreType === 'mate') {
                const mateIn = scoreValue;
                evalValue = mateIn > 0 ? 100 : -100;
                evalText = mateIn > 0 ? `M${Math.abs(mateIn)}` : `-M${Math.abs(mateIn)}`;
                if (!isWhiteToMove) {
                    evalValue = -evalValue;
                    evalText = mateIn > 0 ? `-M${Math.abs(mateIn)}` : `M${Math.abs(mateIn)}`;
                }
            } else {
                evalValue = scoreValue / 100;
                if (!isWhiteToMove) {
                    evalValue = -evalValue;
                }
                evalText = (evalValue >= 0 ? '+' : '') + evalValue.toFixed(1);
            }
            analysisBySide[currentAnalysisSide][pvNum] = { depth, eval: evalValue, evalText, moves: pvMoves };
            updateAnalysisDisplayForSide(currentAnalysisSide, depth);
        }

        function updateAnalysisDisplayForSide(side, depth) {
            const numLines = parseInt(multiPV.value);
            const lines = analysisBySide[side];
            let bestLine = null;
            for (let i = 1; i <= numLines; i++) {
                const line = lines[i];
                if (!line) continue;
                if (!bestLine || line.eval > bestLine.eval) bestLine = line;
            }
            if (!bestLine) return;

            if (side === 'white') {
                currentDepthWhite.textContent = "Depth: " + depth;
                thinkingIndicatorWhite.classList.remove('hidden');
                evalScoreBarWhite.textContent = bestLine.evalText;
                const barPercent = 50 + (Math.tanh(bestLine.eval / 6) * 50);
                evalFillWhite.style.height = `${barPercent}%`;
                evalScoreBarWhite.style.top = `${100 - barPercent}%`;
                const whitePercent = barPercent;
                const blackPercent = 100 - barPercent;
                evalInlineWhiteRightFill.style.width = `${whitePercent}%`;
                evalInlineWhiteLeftFill.style.width = `${blackPercent}%`;
                evalInlineWhiteLabel.textContent = bestLine.evalText;
                if (bestLine.moves.length > 0) bestMoveWhite.textContent = formatMove(bestLine.moves[0]);
            } else {
                currentDepthBlack.textContent = "Depth: " + depth;;
                thinkingIndicatorBlack.classList.remove('hidden');
                evalScoreBarBlack.textContent = bestLine.evalText;
                const barPercent = 50 + (Math.tanh(bestLine.eval / 6) * 50);
                evalFillBlack.style.height = `${barPercent}%`;
                evalScoreBarBlack.style.top = `${100 - barPercent}%`;
                const whitePercent = barPercent;
                const blackPercent = 100 - barPercent;
                evalInlineBlackRightFill.style.width = `${whitePercent}%`;
                evalInlineBlackLeftFill.style.width = `${blackPercent}%`;
                evalInlineBlackLabel.textContent = bestLine.evalText;
                if (bestLine.moves.length > 0) bestMoveBlack.textContent = formatMove(bestLine.moves[0]);
            }

            const sortedLines = [];
            for (let i = 1; i <= numLines; i++) {
                if (lines[i]) sortedLines.push(lines[i]);
            }
            sortedLines.sort((a, b) => b.eval - a.eval);

            let linesHTML = '';
            for (const line of sortedLines) {
                const movesStr = formatMoveSequenceColored(line.moves, side);
                const evalClass = 'text-indigo-400';
                linesHTML += `
                    <div class="analysis-line">
                        <span class="${evalClass} font-bold">${line.evalText}</span>
                        <span class="ml-2">${movesStr}</span>
                    </div>
                `;
            }
            if (side === 'white') {
                analysisLinesWhite.innerHTML = linesHTML || '<p class="text-slate-500 text-xs text-center py-2">Analyzing...</p>';
            } else {
                analysisLinesBlack.innerHTML = linesHTML || '<p class="text-slate-500 text-xs text-center py-2">Analyzing...</p>';
            }
        }

        function formatMoveSequenceColored(uciMoves, side) {
            if (!uciMoves || uciMoves.length === 0) return '';
            const currentBoard = getCurrentBoard();
            let tempBoard = copyBoard(currentBoard);
            const tokens = [];
            for (let i = 0; i < uciMoves.length; i++) {
                const uciMove = uciMoves[i];
                const sanMove = formatMove(uciMove, tempBoard);
                const isWhiteMove = (side === 'white') ? (i % 2 === 0) : (i % 2 !== 0);
                const cls = isWhiteMove ? 'move-token-white' : 'move-token-black';
                tokens.push(`<span class="${cls}">${sanMove}</span>`);
                tempBoard = applyUCIMove(tempBoard, uciMove);
                if (!tempBoard) break;
            }
            return tokens.join(' ');
        }

        // Apply a UCI move to a board (returns new board)
        function applyUCIMove(board, uciMove) {
            if (!uciMove || uciMove.length < 4) return null;

            const newBoard = copyBoard(board);
            const fromSquare = uciMove.substring(0, 2);
            const toSquare = uciMove.substring(2, 4);
            const promotion = uciMove.length > 4 ? uciMove[4].toLowerCase() : null;

            const fromCol = fromSquare.charCodeAt(0) - 97;
            const fromRow = 8 - parseInt(fromSquare[1]);
            const toCol = toSquare.charCodeAt(0) - 97;
            const toRow = 8 - parseInt(toSquare[1]);

            const piece = newBoard[fromRow][fromCol];
            if (!piece) return null;

            const pieceType = piece.toUpperCase();
            const isWhite = piece === piece.toUpperCase();

            // Handle castling
            if (pieceType === 'K' && Math.abs(toCol - fromCol) === 2) {
                const row = fromRow;
                if (toCol > fromCol) { // Kingside
                    newBoard[row][6] = newBoard[row][4];
                    newBoard[row][5] = newBoard[row][7];
                    newBoard[row][4] = null;
                    newBoard[row][7] = null;
                } else { // Queenside
                    newBoard[row][2] = newBoard[row][4];
                    newBoard[row][3] = newBoard[row][0];
                    newBoard[row][4] = null;
                    newBoard[row][0] = null;
                }
                return newBoard;
            }

            // Handle en passant
            if (pieceType === 'P' && fromCol !== toCol && !newBoard[toRow][toCol]) {
                newBoard[fromRow][toCol] = null;
            }

            // Move the piece
            if (promotion) {
                newBoard[toRow][toCol] = isWhite ? promotion.toUpperCase() : promotion.toLowerCase();
            } else {
                newBoard[toRow][toCol] = piece;
            }
            newBoard[fromRow][fromCol] = null;

            return newBoard;
        }

        function formatMove(uciMove, board = null) {
            if (!uciMove || uciMove.length < 4) return uciMove;

            // Use current board if not provided
            if (!board) {
                board = getCurrentBoard();
            }

            const fromSquare = uciMove.substring(0, 2);
            const toSquare = uciMove.substring(2, 4);
            const promotion = uciMove.length > 4 ? uciMove[4].toUpperCase() : null;

            // Parse squares
            const fromCol = fromSquare.charCodeAt(0) - 97; // a=0, b=1, etc.
            const fromRow = 8 - parseInt(fromSquare[1]); // 8=0, 7=1, etc.
            const toCol = toSquare.charCodeAt(0) - 97;
            const toRow = 8 - parseInt(toSquare[1]);

            // Get the piece being moved
            const piece = board[fromRow][fromCol];
            if (!piece) return uciMove; // Fallback if no piece found

            const pieceType = piece.toUpperCase();
            const isWhite = piece === piece.toUpperCase();

            // Check for castling
            if (pieceType === 'K') {
                const colDiff = toCol - fromCol;
                if (Math.abs(colDiff) === 2) {
                    return colDiff > 0 ? 'O-O' : 'O-O-O';
                }
            }

            // Check if it's a capture
            const isCapture = board[toRow][toCol] !== null ||
                (pieceType === 'P' && fromCol !== toCol && board[toRow][toCol] === null); // En passant

            // Build the move notation
            let san = '';

            // Add piece letter (except for pawns)
            if (pieceType !== 'P') {
                san += pieceType;

                // Check if disambiguation is needed
                const disambiguation = getDisambiguation(board, piece, fromRow, fromCol, toRow, toCol, pieceType, isWhite);
                san += disambiguation;
            } else if (isCapture) {
                // For pawn captures, include the starting file
                san += fromSquare[0];
            }

            // Add capture symbol
            if (isCapture) {
                san += 'x';
            }

            // Add destination square
            san += toSquare;

            // Add promotion
            if (promotion) {
                san += '=' + promotion;
            }

            return san;
        }

        // Helper function to determine if disambiguation is needed
        function getDisambiguation(board, piece, fromRow, fromCol, toRow, toCol, pieceType, isWhite) {
            // Only needed for non-pawn pieces
            if (pieceType === 'P' || pieceType === 'K') return '';

            // Find all pieces of the same type that can move to the same square
            const candidates = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === piece && !(r === fromRow && c === fromCol)) {
                        if (canMove(board, r, c, toRow, toCol, pieceType, isWhite)) {
                            candidates.push({ row: r, col: c });
                        }
                    }
                }
            }

            if (candidates.length === 0) return '';

            // Check if file disambiguation is enough
            const sameFile = candidates.filter(p => p.col === fromCol);
            if (sameFile.length === 0) {
                return String.fromCharCode(97 + fromCol); // Return file letter
            }

            // Check if rank disambiguation is enough
            const sameRank = candidates.filter(p => p.row === fromRow);
            if (sameRank.length === 0) {
                return String(8 - fromRow); // Return rank number
            }

            // Need both file and rank
            return String.fromCharCode(97 + fromCol) + String(8 - fromRow);
        }

        function analyzeCurrentPosition() {
            if (!engineReady || !engineEnabled) return;
            const board = getCurrentBoard();
            const fenWhite = boardToFEN(board, true);
            const fenBlack = boardToFEN(board, false);
            const marker = fenWhite + '|' + fenBlack;
            if (marker === lastAnalyzedFen) return;
            currentAnalysisId++;
            const thisAnalysisId = currentAnalysisId;
            if (analysisTimeout) {
                clearTimeout(analysisTimeout);
                analysisTimeout = null;
            }
            lastAnalyzedFen = marker;
            analysisBySide = { white: {}, black: {} };
            thinkingIndicatorWhite.classList.remove('hidden');
            thinkingIndicatorBlack.classList.remove('hidden');
            stockfish.postMessage('stop');
            analysisTimeout = setTimeout(() => {
                if (thisAnalysisId !== currentAnalysisId) return;
                activeAnalysisId = thisAnalysisId; // Mark this ID as active
                isAnalyzing = true;
                currentAnalysisSide = 'white';
                stockfish.postMessage('position fen ' + fenWhite);
                stockfish.postMessage('go depth ' + depthSlider.value);
            }, 100);
        }

        engineToggle.addEventListener('click', async () => {
            engineEnabled = !engineEnabled;
            engineToggle.classList.toggle('active', engineEnabled);

            if (engineEnabled) {
                if (!stockfish) {
                    await initStockfish();
                } else if (engineReady) {
                    engineSettings.classList.remove('hidden');
                    analysisDisplay.classList.remove('hidden');
                    engineOffState.classList.add('hidden');
                    engineVersionSelector.classList.add('hidden');
                    engineStatus.textContent = 'Ready';
                    analyzeCurrentPosition();
                }
            } else {
                if (stockfish) {
                    stockfish.postMessage('stop');
                    stockfish.terminate();
                    stockfish = null;
                    engineReady = false;
                }
                engineSettings.classList.add('hidden');
                analysisDisplay.classList.add('hidden');
                engineOffState.classList.remove('hidden');
                engineVersionSelector.classList.remove('hidden'); // Show version selector when off
                engineStatus.textContent = 'Off';
                isAnalyzing = false;
            }
        });

        depthSlider.addEventListener('input', (e) => {
            depthValue.textContent = e.target.value;
        });

        depthSlider.addEventListener('change', () => {
            if (engineEnabled) {
                lastAnalyzedFen = '';
                analyzeCurrentPosition();
            }
        });

        // Board Theme Selector
        const boardThemeSelect = document.getElementById('boardThemeSelect');
        boardThemeSelect.addEventListener('change', (e) => {
            const theme = e.target.value;
            chessBoard.className = `chess-board w-full ${theme}`;
        });

        // Set initial theme
        chessBoard.classList.add('theme-classic');

        multiPV.addEventListener('change', () => {
            if (stockfish && engineReady) {
                stockfish.postMessage('setoption name MultiPV value ' + multiPV.value);
                if (engineEnabled) {
                    lastAnalyzedFen = '';
                    analyzeCurrentPosition();
                }
            }
        });
    </script>
</body>

</html>